<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# //Template-Version: 15.04.2025

////////////////////////////////////////////////////////////////
//                                                            //
//  THIS IS A TEMPLATE TO BE INCLUDED INTO YOUR PROJECT,      //
//  IT WILL DOWNLOAD AND AGGREGATE SOURCES. EMITTING          //
//  COMPLIANT LOG-MESSAGES INTO THE TRACE-CHANNEL WILL WORK   //
//  WITHOUT HAVING A REFERECNE TO SmartStandards.Logging.dll  //
//                                                            //
////////////////////////////////////////////////////////////////

    string projectUrl = "https://github.com/SmartStandards/Logging";
    string repositoryRootUrl = "https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/";

    string[] fileDownloadUrls = new string[] {

      "Logging/SmartStandards/DevLogger.PerLevel.cs",
      "Logging/SmartStandards/DevLogger.WoSourceContext.cs",
      "Logging/SmartStandards/ExceptionExtensions.cs",

      "Logging/SmartStandards/Internal/ExceptionAnalyzer.cs",

      "Logging/SmartStandards/TemplateHousekeeping/LogMessageEnumConverter.cs",
      "Logging/SmartStandards/TemplateHousekeeping/LogMessageTemplateAttribute.cs",
      "Logging/SmartStandards/TemplateHousekeeping/LogMessageTemplateRepository.cs",

      "Logging/SmartStandards/Textualization/CopyOfPlaceholderExtensions .cs",
      "Logging/SmartStandards/Textualization/ExceptionRenderer.cs",
      "Logging/SmartStandards/Textualization/LogParaphRenderer.cs",
      "Logging/SmartStandards/Textualization/LogParaphParser.cs",

      "Logging/SmartStandards/Transport/CutomBusFeed.cs",
      "Logging/SmartStandards/Transport/TraceBusFeed.cs",
      "Logging/SmartStandards/Transport/TraceBusFeed.Buffer.cs",
      "Logging/SmartStandards/Transport/TraceBusListener.cs"

    };

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    string content = "//-----------------------------------------------------------------------\n//<auto-generated>\n// THIS CODE IS AN AUTOMATIC MIRROR OF: " + projectUrl + " (thanks to the autor!)\n//</auto-generated>\n//-----------------------------------------------------------------------\n\n{usings}\n";
    string currentFileUrl = "";
    try {

      StringBuilder aggregatedContent = new StringBuilder(10000);
      List<string> usings = new List<string>();

      aggregatedContent.AppendLine();
      aggregatedContent.AppendLine("// " + new string('#', projectUrl.Length + 34));
      aggregatedContent.AppendLine("// # DOWNLOADED FROM " + projectUrl + " AT " + DateTime.Now.ToShortDateString() + " #");
      aggregatedContent.AppendLine("// " + new string('#', projectUrl.Length + 34));

      foreach (string fileDownloadUrl in fileDownloadUrls) {
        using (var wc = new System.Net.WebClient()) {
          currentFileUrl = repositoryRootUrl + fileDownloadUrl;
          string fileContent = wc.DownloadString(currentFileUrl);

          using (TextReader reader = new StringReader(fileContent)) {
            string currentLine = reader.ReadLine();

            aggregatedContent.AppendLine();
            aggregatedContent.AppendLine("// (File: " + currentFileUrl + ")");

            while (currentLine != null) {
              if (currentLine.StartsWith("using")) {
                usings.Add(currentLine);
              }
              else if (currentLine.StartsWith("[assembly:")) {
                //skip
              }
              else {
                aggregatedContent.AppendLine(currentLine);
              }
              currentLine = reader.ReadLine();
            }
          }
        }
      }

      string sourceInfo = "Mirrored file from GitHub";
      string vers = DateTime.Now.ToShortDateString();
      string compilerGeneratedAttributes = ""; //"[CompilerGenerated()][GeneratedCode(tool:\"" + sourceInfo + "\", version:\"" + vers + "\")]";

      aggregatedContent = aggregatedContent.Replace("partial class", "class");
      aggregatedContent = aggregatedContent.Replace("public class", compilerGeneratedAttributes + "\n  internal class");
      aggregatedContent = aggregatedContent.Replace("public static class", compilerGeneratedAttributes + "\n  internal static class");
      aggregatedContent = aggregatedContent.Replace("public interface", compilerGeneratedAttributes + "\n  internal clinterfaceass");
      aggregatedContent = aggregatedContent.Replace("public static interface", compilerGeneratedAttributes + "\n  internal static interface");
      aggregatedContent = aggregatedContent.Replace("public enum", compilerGeneratedAttributes + "\n  internal enum");
      aggregatedContent = aggregatedContent.Replace("class", "partial class");
      aggregatedContent = aggregatedContent.Replace("partial partial", "partial");

      //mandatory usings
      usings.Add("using System;");
      usings.Add("using System.Security.Cryptography;");
      usings.Add("using System.Reflection;");
      usings.Add("using System.ComponentModel;");
      usings.Add("using System.Text;");
      usings.Add("using System.IO;");
      usings.Add("using System.CodeDom.Compiler;");
      usings.Add("using System.Runtime.CompilerServices;");

      aggregatedContent.Insert(0, string.Join(Environment.NewLine, usings.Distinct().OrderBy((u)=>u)) + Environment.NewLine);
      aggregatedContent.ToString();

      content = aggregatedContent.ToString();
    }
    catch (Exception ex) {
      content = "Error Processing '" + currentFileUrl + "': " + ex.Message;
    }
#><#= content #>

namespace Logging.SmartStandards {
 
  internal partial class DevLogger {

    public const string AudienceToken = "Dev";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int kindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      Logging.SmartStandards.Transport.TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, kindId, messageTemplate, args);

    }

    public static void Log(int level, string sourceContext, long sourceLineId, Enum kindEnumElement, params object[] args) {
      TemplateHousekeeping.LogMessageTemplateRepository.GetMessageTemplateByKind(kindEnumElement, out int kindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, kindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {
      int kindId = Logging.SmartStandards.Internal.ExceptionAnalyzer.InferEventIdByException(ex);
      Logging.SmartStandards.Transport.TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, kindId, ex); 
    }

  }
}

/*********************** SAMPLES **********************************
     
  [TypeConverter(typeof(LogMessageEnumConverter))]
  internal enum LogMessages {

    /// <summary>       "Weve got a Foo!" </summary>
    [LogMessageTemplate("Weve got a Foo!")]
    Foo = 110011,

    /// <summary>       "Weve got a Bar!" </summary>
    [LogMessageTemplate("Weve got a Bar!")]
    Bar = 220022

  }

  DevLogger.LogError(LogMessages.Bar);
  DevLogger.LogError(0, 2282, "A Freetext-Message");

  DevLogger.LogError(ex);
  DevLogger.LogError(ex.Wrap(22, "Another message"));
  DevLogger.LogError(ex.Wrap("Another message B"));
      
*/

<#+ 
///////////////////// HERE ENDS OWN ADDITIONAL CODE ///////////////////////////////////////////////////////////////
  string EnsureUsing(string content, string ns){  
    if(!content.Contains("using " + ns + ";")){
      content = content.Replace("{usings}\n","using " + ns + ";\n{usings}\n");    
    }
    return content;
  }
#>